# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Emoji implements Node {
  id: ID!
  name: String!
  code: String!
  image: String!
  type: EmojiType!
  premium: Boolean!
}

type Location implements Node {
  id: ID!
  name: String!
  latitude: Float!
  longitude: Float!
}

type Media implements Node {
  id: ID!
  type: MediaType!
  url: String!
}

type Post implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  text: String!
  author(where: UserWhereInput): User!
  reactions(where: ReactionWhereInput, orderBy: ReactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reaction!]
  with(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  location(where: LocationWhereInput): Location
  visibility: VisibilityFilter!
  exclude(where: FriendWhereInput, orderBy: FriendOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Friend!]
  media(where: MediaWhereInput, orderBy: MediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Media!]
  ip: String!
}

type Reaction implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  by(where: UserWhereInput): User!
  type(where: EmojiWhereInput): Emoji!
}

type User implements Node {
  id: ID!
  username: String!
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  friends(where: FriendWhereInput, orderBy: FriendOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Friend!]
  followers(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  following(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}


#
# Other Types
#

type AggregateBlockedUser {
  count: Int!
}

type AggregateEmoji {
  count: Int!
}

type AggregateFriend {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMedia {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateReaction {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type BlockedUser {
  createdAt: DateTime!
  user(where: UserWhereInput): User!
}

type BlockedUserConnection {
  pageInfo: PageInfo!
  edges: [BlockedUserEdge]!
  aggregate: AggregateBlockedUser!
}

input BlockedUserCreateInput {
  user: UserCreateOneInput!
}

type BlockedUserEdge {
  node: BlockedUser!
  cursor: String!
}

enum BlockedUserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BlockedUserPreviousValues {
  createdAt: DateTime!
}

type BlockedUserSubscriptionPayload {
  mutation: MutationType!
  node: BlockedUser
  updatedFields: [String!]
  previousValues: BlockedUserPreviousValues
}

input BlockedUserSubscriptionWhereInput {
  AND: [BlockedUserSubscriptionWhereInput!]
  OR: [BlockedUserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BlockedUserWhereInput
}

input BlockedUserUpdateInput {
  user: UserUpdateOneInput
}

input BlockedUserWhereInput {
  AND: [BlockedUserWhereInput!]
  OR: [BlockedUserWhereInput!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  user: UserWhereInput
}

scalar DateTime

type EmojiConnection {
  pageInfo: PageInfo!
  edges: [EmojiEdge]!
  aggregate: AggregateEmoji!
}

input EmojiCreateInput {
  name: String!
  code: String!
  image: String!
  type: EmojiType
  premium: Boolean
}

input EmojiCreateOneInput {
  create: EmojiCreateInput
  connect: EmojiWhereUniqueInput
}

type EmojiEdge {
  node: Emoji!
  cursor: String!
}

enum EmojiOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  code_ASC
  code_DESC
  image_ASC
  image_DESC
  type_ASC
  type_DESC
  premium_ASC
  premium_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type EmojiPreviousValues {
  id: ID!
  name: String!
  code: String!
  image: String!
  type: EmojiType!
  premium: Boolean!
}

type EmojiSubscriptionPayload {
  mutation: MutationType!
  node: Emoji
  updatedFields: [String!]
  previousValues: EmojiPreviousValues
}

input EmojiSubscriptionWhereInput {
  AND: [EmojiSubscriptionWhereInput!]
  OR: [EmojiSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmojiWhereInput
}

enum EmojiType {
  Basic
  Limited
  Custom
}

input EmojiUpdateInput {
  name: String
  code: String
  image: String
  type: EmojiType
  premium: Boolean
}

input EmojiUpdateOneInput {
  create: EmojiCreateInput
  connect: EmojiWhereUniqueInput
  disconnect: EmojiWhereUniqueInput
  delete: EmojiWhereUniqueInput
}

input EmojiWhereInput {
  AND: [EmojiWhereInput!]
  OR: [EmojiWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  type: EmojiType
  type_not: EmojiType
  type_in: [EmojiType!]
  type_not_in: [EmojiType!]
  premium: Boolean
  premium_not: Boolean
}

input EmojiWhereUniqueInput {
  id: ID
}

type Friend {
  createdAt: DateTime!
  user(where: UserWhereInput): User!
  relationship: Relationship!
}

type FriendConnection {
  pageInfo: PageInfo!
  edges: [FriendEdge]!
  aggregate: AggregateFriend!
}

input FriendCreateInput {
  relationship: Relationship!
  user: UserCreateOneWithoutFriendsInput!
}

input FriendCreateManyInput {
  create: [FriendCreateInput!]
}

input FriendCreateManyWithoutUserInput {
  create: [FriendCreateWithoutUserInput!]
}

input FriendCreateWithoutUserInput {
  relationship: Relationship!
}

type FriendEdge {
  node: Friend!
  cursor: String!
}

enum FriendOrderByInput {
  createdAt_ASC
  createdAt_DESC
  relationship_ASC
  relationship_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FriendPreviousValues {
  createdAt: DateTime!
  relationship: Relationship!
}

type FriendSubscriptionPayload {
  mutation: MutationType!
  node: Friend
  updatedFields: [String!]
  previousValues: FriendPreviousValues
}

input FriendSubscriptionWhereInput {
  AND: [FriendSubscriptionWhereInput!]
  OR: [FriendSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FriendWhereInput
}

input FriendUpdateInput {
  relationship: Relationship
  user: UserUpdateOneWithoutFriendsInput
}

input FriendUpdateManyInput {
  create: [FriendCreateInput!]
}

input FriendUpdateManyWithoutUserInput {
  create: [FriendCreateWithoutUserInput!]
}

input FriendWhereInput {
  AND: [FriendWhereInput!]
  OR: [FriendWhereInput!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  relationship: Relationship
  relationship_not: Relationship
  relationship_in: [Relationship!]
  relationship_not_in: [Relationship!]
  user: UserWhereInput
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  name: String!
  latitude: Float!
  longitude: Float!
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type LocationPreviousValues {
  id: ID!
  name: String!
  latitude: Float!
  longitude: Float!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
}

input LocationUpdateInput {
  name: String
  latitude: Float
  longitude: Float
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
  disconnect: LocationWhereUniqueInput
  delete: LocationWhereUniqueInput
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type MediaConnection {
  pageInfo: PageInfo!
  edges: [MediaEdge]!
  aggregate: AggregateMedia!
}

input MediaCreateInput {
  type: MediaType
  url: String!
}

input MediaCreateManyInput {
  create: [MediaCreateInput!]
  connect: [MediaWhereUniqueInput!]
}

type MediaEdge {
  node: Media!
  cursor: String!
}

enum MediaOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  url_ASC
  url_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type MediaPreviousValues {
  id: ID!
  type: MediaType!
  url: String!
}

type MediaSubscriptionPayload {
  mutation: MutationType!
  node: Media
  updatedFields: [String!]
  previousValues: MediaPreviousValues
}

input MediaSubscriptionWhereInput {
  AND: [MediaSubscriptionWhereInput!]
  OR: [MediaSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MediaWhereInput
}

enum MediaType {
  Photo
  Video
  Link
}

input MediaUpdateInput {
  type: MediaType
  url: String
}

input MediaUpdateManyInput {
  create: [MediaCreateInput!]
  connect: [MediaWhereUniqueInput!]
  disconnect: [MediaWhereUniqueInput!]
  delete: [MediaWhereUniqueInput!]
}

input MediaWhereInput {
  AND: [MediaWhereInput!]
  OR: [MediaWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: MediaType
  type_not: MediaType
  type_in: [MediaType!]
  type_not_in: [MediaType!]
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
}

input MediaWhereUniqueInput {
  id: ID
  url: String
}

type Mutation {
  createPost(data: PostCreateInput!): Post!
  createLocation(data: LocationCreateInput!): Location!
  createMedia(data: MediaCreateInput!): Media!
  createUser(data: UserCreateInput!): User!
  createTag(data: TagCreateInput!): Tag!
  createBlockedUser(data: BlockedUserCreateInput!): BlockedUser!
  createFriend(data: FriendCreateInput!): Friend!
  createReaction(data: ReactionCreateInput!): Reaction!
  createEmoji(data: EmojiCreateInput!): Emoji!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateMedia(data: MediaUpdateInput!, where: MediaWhereUniqueInput!): Media
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateReaction(data: ReactionUpdateInput!, where: ReactionWhereUniqueInput!): Reaction
  updateEmoji(data: EmojiUpdateInput!, where: EmojiWhereUniqueInput!): Emoji
  deletePost(where: PostWhereUniqueInput!): Post
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteMedia(where: MediaWhereUniqueInput!): Media
  deleteUser(where: UserWhereUniqueInput!): User
  deleteReaction(where: ReactionWhereUniqueInput!): Reaction
  deleteEmoji(where: EmojiWhereUniqueInput!): Emoji
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  upsertMedia(where: MediaWhereUniqueInput!, create: MediaCreateInput!, update: MediaUpdateInput!): Media!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  upsertReaction(where: ReactionWhereUniqueInput!, create: ReactionCreateInput!, update: ReactionUpdateInput!): Reaction!
  upsertEmoji(where: EmojiWhereUniqueInput!, create: EmojiCreateInput!, update: EmojiUpdateInput!): Emoji!
  updateManyPosts(data: PostUpdateInput!, where: PostWhereInput!): BatchPayload!
  updateManyLocations(data: LocationUpdateInput!, where: LocationWhereInput!): BatchPayload!
  updateManyMedias(data: MediaUpdateInput!, where: MediaWhereInput!): BatchPayload!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!
  updateManyTags(data: TagUpdateInput!, where: TagWhereInput!): BatchPayload!
  updateManyBlockedUsers(data: BlockedUserUpdateInput!, where: BlockedUserWhereInput!): BatchPayload!
  updateManyFriends(data: FriendUpdateInput!, where: FriendWhereInput!): BatchPayload!
  updateManyReactions(data: ReactionUpdateInput!, where: ReactionWhereInput!): BatchPayload!
  updateManyEmojis(data: EmojiUpdateInput!, where: EmojiWhereInput!): BatchPayload!
  deleteManyPosts(where: PostWhereInput!): BatchPayload!
  deleteManyLocations(where: LocationWhereInput!): BatchPayload!
  deleteManyMedias(where: MediaWhereInput!): BatchPayload!
  deleteManyUsers(where: UserWhereInput!): BatchPayload!
  deleteManyTags(where: TagWhereInput!): BatchPayload!
  deleteManyBlockedUsers(where: BlockedUserWhereInput!): BatchPayload!
  deleteManyFriends(where: FriendWhereInput!): BatchPayload!
  deleteManyReactions(where: ReactionWhereInput!): BatchPayload!
  deleteManyEmojis(where: EmojiWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  deletedAt: DateTime
  text: String!
  visibility: VisibilityFilter
  ip: String!
  author: UserCreateOneWithoutPostsInput!
  reactions: ReactionCreateManyInput
  with: TagCreateManyWithoutPostInput
  location: LocationCreateOneInput
  exclude: FriendCreateManyInput
  media: MediaCreateManyInput
}

input PostCreateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateOneWithoutWithInput {
  create: PostCreateWithoutWithInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutAuthorInput {
  deletedAt: DateTime
  text: String!
  visibility: VisibilityFilter
  ip: String!
  reactions: ReactionCreateManyInput
  with: TagCreateManyWithoutPostInput
  location: LocationCreateOneInput
  exclude: FriendCreateManyInput
  media: MediaCreateManyInput
}

input PostCreateWithoutWithInput {
  deletedAt: DateTime
  text: String!
  visibility: VisibilityFilter
  ip: String!
  author: UserCreateOneWithoutPostsInput!
  reactions: ReactionCreateManyInput
  location: LocationCreateOneInput
  exclude: FriendCreateManyInput
  media: MediaCreateManyInput
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  text_ASC
  text_DESC
  visibility_ASC
  visibility_DESC
  ip_ASC
  ip_DESC
}

type PostPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  text: String!
  visibility: VisibilityFilter!
  ip: String!
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
}

input PostUpdateInput {
  deletedAt: DateTime
  text: String
  visibility: VisibilityFilter
  ip: String
  author: UserUpdateOneWithoutPostsInput
  reactions: ReactionUpdateManyInput
  with: TagUpdateManyWithoutPostInput
  location: LocationUpdateOneInput
  exclude: FriendUpdateManyInput
  media: MediaUpdateManyInput
}

input PostUpdateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  connect: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  delete: [PostWhereUniqueInput!]
  update: [PostUpdateWithoutAuthorInput!]
  upsert: [PostUpsertWithoutAuthorInput!]
}

input PostUpdateOneWithoutWithInput {
  create: PostCreateWithoutWithInput
  connect: PostWhereUniqueInput
  disconnect: PostWhereUniqueInput
  delete: PostWhereUniqueInput
  update: PostUpdateWithoutWithInput
  upsert: PostUpsertWithoutWithInput
}

input PostUpdateWithoutAuthorDataInput {
  deletedAt: DateTime
  text: String
  visibility: VisibilityFilter
  ip: String
  reactions: ReactionUpdateManyInput
  with: TagUpdateManyWithoutPostInput
  location: LocationUpdateOneInput
  exclude: FriendUpdateManyInput
  media: MediaUpdateManyInput
}

input PostUpdateWithoutAuthorInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutAuthorDataInput!
}

input PostUpdateWithoutWithDataInput {
  deletedAt: DateTime
  text: String
  visibility: VisibilityFilter
  ip: String
  author: UserUpdateOneWithoutPostsInput
  reactions: ReactionUpdateManyInput
  location: LocationUpdateOneInput
  exclude: FriendUpdateManyInput
  media: MediaUpdateManyInput
}

input PostUpdateWithoutWithInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutWithDataInput!
}

input PostUpsertWithoutAuthorInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutAuthorDataInput!
  create: PostCreateWithoutAuthorInput!
}

input PostUpsertWithoutWithInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutWithDataInput!
  create: PostCreateWithoutWithInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  visibility: VisibilityFilter
  visibility_not: VisibilityFilter
  visibility_in: [VisibilityFilter!]
  visibility_not_in: [VisibilityFilter!]
  ip: String
  ip_not: String
  ip_in: [String!]
  ip_not_in: [String!]
  ip_lt: String
  ip_lte: String
  ip_gt: String
  ip_gte: String
  ip_contains: String
  ip_not_contains: String
  ip_starts_with: String
  ip_not_starts_with: String
  ip_ends_with: String
  ip_not_ends_with: String
  author: UserWhereInput
  reactions_every: ReactionWhereInput
  reactions_some: ReactionWhereInput
  reactions_none: ReactionWhereInput
  with_every: TagWhereInput
  with_some: TagWhereInput
  with_none: TagWhereInput
  location: LocationWhereInput
  exclude_every: FriendWhereInput
  exclude_some: FriendWhereInput
  exclude_none: FriendWhereInput
  media_every: MediaWhereInput
  media_some: MediaWhereInput
  media_none: MediaWhereInput
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  medias(where: MediaWhereInput, orderBy: MediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Media]!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  blockedUsers(where: BlockedUserWhereInput, orderBy: BlockedUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BlockedUser]!
  friends(where: FriendWhereInput, orderBy: FriendOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Friend]!
  reactions(where: ReactionWhereInput, orderBy: ReactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reaction]!
  emojis(where: EmojiWhereInput, orderBy: EmojiOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Emoji]!
  post(where: PostWhereUniqueInput!): Post
  location(where: LocationWhereUniqueInput!): Location
  media(where: MediaWhereUniqueInput!): Media
  user(where: UserWhereUniqueInput!): User
  reaction(where: ReactionWhereUniqueInput!): Reaction
  emoji(where: EmojiWhereUniqueInput!): Emoji
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  mediasConnection(where: MediaWhereInput, orderBy: MediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MediaConnection!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  blockedUsersConnection(where: BlockedUserWhereInput, orderBy: BlockedUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BlockedUserConnection!
  friendsConnection(where: FriendWhereInput, orderBy: FriendOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FriendConnection!
  reactionsConnection(where: ReactionWhereInput, orderBy: ReactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReactionConnection!
  emojisConnection(where: EmojiWhereInput, orderBy: EmojiOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmojiConnection!
  node(id: ID!): Node
}

type ReactionConnection {
  pageInfo: PageInfo!
  edges: [ReactionEdge]!
  aggregate: AggregateReaction!
}

input ReactionCreateInput {
  by: UserCreateOneInput!
  type: EmojiCreateOneInput!
}

input ReactionCreateManyInput {
  create: [ReactionCreateInput!]
  connect: [ReactionWhereUniqueInput!]
}

type ReactionEdge {
  node: Reaction!
  cursor: String!
}

enum ReactionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ReactionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReactionSubscriptionPayload {
  mutation: MutationType!
  node: Reaction
  updatedFields: [String!]
  previousValues: ReactionPreviousValues
}

input ReactionSubscriptionWhereInput {
  AND: [ReactionSubscriptionWhereInput!]
  OR: [ReactionSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReactionWhereInput
}

input ReactionUpdateInput {
  by: UserUpdateOneInput
  type: EmojiUpdateOneInput
}

input ReactionUpdateManyInput {
  create: [ReactionCreateInput!]
  connect: [ReactionWhereUniqueInput!]
  disconnect: [ReactionWhereUniqueInput!]
  delete: [ReactionWhereUniqueInput!]
}

input ReactionWhereInput {
  AND: [ReactionWhereInput!]
  OR: [ReactionWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  by: UserWhereInput
  type: EmojiWhereInput
}

input ReactionWhereUniqueInput {
  id: ID
}

enum Relationship {
  Acquaintence
  Friend
  Close
  Family
}

type Subscription {
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  media(where: MediaSubscriptionWhereInput): MediaSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  blockedUser(where: BlockedUserSubscriptionWhereInput): BlockedUserSubscriptionPayload
  friend(where: FriendSubscriptionWhereInput): FriendSubscriptionPayload
  reaction(where: ReactionSubscriptionWhereInput): ReactionSubscriptionPayload
  emoji(where: EmojiSubscriptionWhereInput): EmojiSubscriptionPayload
}

type Tag {
  createdAt: DateTime!
  user(where: UserWhereInput): User!
  post(where: PostWhereInput): Post!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  user: UserCreateOneWithoutTagsInput!
  post: PostCreateOneWithoutWithInput!
}

input TagCreateManyWithoutPostInput {
  create: [TagCreateWithoutPostInput!]
}

input TagCreateManyWithoutUserInput {
  create: [TagCreateWithoutUserInput!]
}

input TagCreateWithoutPostInput {
  user: UserCreateOneWithoutTagsInput!
}

input TagCreateWithoutUserInput {
  post: PostCreateOneWithoutWithInput!
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TagPreviousValues {
  createdAt: DateTime!
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
}

input TagUpdateInput {
  user: UserUpdateOneWithoutTagsInput
  post: PostUpdateOneWithoutWithInput
}

input TagUpdateManyWithoutPostInput {
  create: [TagCreateWithoutPostInput!]
}

input TagUpdateManyWithoutUserInput {
  create: [TagCreateWithoutUserInput!]
}

input TagWhereInput {
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  user: UserWhereInput
  post: PostWhereInput
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  username: String!
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  posts: PostCreateManyWithoutAuthorInput
  tags: TagCreateManyWithoutUserInput
  friends: FriendCreateManyWithoutUserInput
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
}

input UserCreateManyWithoutFollowersInput {
  create: [UserCreateWithoutFollowersInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutFollowingInput {
  create: [UserCreateWithoutFollowersInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFriendsInput {
  create: UserCreateWithoutFriendsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTagsInput {
  create: UserCreateWithoutTagsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutFollowersInput {
  username: String!
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  posts: PostCreateManyWithoutAuthorInput
  tags: TagCreateManyWithoutUserInput
  friends: FriendCreateManyWithoutUserInput
}

input UserCreateWithoutFriendsInput {
  username: String!
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  posts: PostCreateManyWithoutAuthorInput
  tags: TagCreateManyWithoutUserInput
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
}

input UserCreateWithoutPostsInput {
  username: String!
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  tags: TagCreateManyWithoutUserInput
  friends: FriendCreateManyWithoutUserInput
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
}

input UserCreateWithoutTagsInput {
  username: String!
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  posts: PostCreateManyWithoutAuthorInput
  friends: FriendCreateManyWithoutUserInput
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  email: String!
  password: String!
  firstName: String!
  lastName: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  username: String
  email: String
  password: String
  firstName: String
  lastName: String
  posts: PostUpdateManyWithoutAuthorInput
  tags: TagUpdateManyWithoutUserInput
  friends: FriendUpdateManyWithoutUserInput
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
}

input UserUpdateManyWithoutFollowersInput {
  create: [UserCreateWithoutFollowersInput!]
  connect: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  update: [UserUpdateWithoutFollowersInput!]
  upsert: [UserUpsertWithoutFollowersInput!]
}

input UserUpdateManyWithoutFollowingInput {
  create: [UserCreateWithoutFollowersInput!]
  connect: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  update: [UserUpdateWithoutFollowersInput!]
  upsert: [UserUpsertWithoutFollowersInput!]
}

input UserUpdateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
}

input UserUpdateOneWithoutFriendsInput {
  create: UserCreateWithoutFriendsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutFriendsInput
  upsert: UserUpsertWithoutFriendsInput
}

input UserUpdateOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutPostsInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateOneWithoutTagsInput {
  create: UserCreateWithoutTagsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutTagsInput
  upsert: UserUpsertWithoutTagsInput
}

input UserUpdateWithoutFollowersDataInput {
  username: String
  email: String
  password: String
  firstName: String
  lastName: String
  posts: PostUpdateManyWithoutAuthorInput
  tags: TagUpdateManyWithoutUserInput
  friends: FriendUpdateManyWithoutUserInput
}

input UserUpdateWithoutFollowersInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutFollowersDataInput!
}

input UserUpdateWithoutFriendsDataInput {
  username: String
  email: String
  password: String
  firstName: String
  lastName: String
  posts: PostUpdateManyWithoutAuthorInput
  tags: TagUpdateManyWithoutUserInput
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
}

input UserUpdateWithoutFriendsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutFriendsDataInput!
}

input UserUpdateWithoutPostsDataInput {
  username: String
  email: String
  password: String
  firstName: String
  lastName: String
  tags: TagUpdateManyWithoutUserInput
  friends: FriendUpdateManyWithoutUserInput
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
}

input UserUpdateWithoutPostsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutPostsDataInput!
}

input UserUpdateWithoutTagsDataInput {
  username: String
  email: String
  password: String
  firstName: String
  lastName: String
  posts: PostUpdateManyWithoutAuthorInput
  friends: FriendUpdateManyWithoutUserInput
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
}

input UserUpdateWithoutTagsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutTagsDataInput!
}

input UserUpsertWithoutFollowersInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutFollowersDataInput!
  create: UserCreateWithoutFollowersInput!
}

input UserUpsertWithoutFriendsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutFriendsDataInput!
  create: UserCreateWithoutFriendsInput!
}

input UserUpsertWithoutPostsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutPostsDataInput!
  create: UserCreateWithoutPostsInput!
}

input UserUpsertWithoutTagsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutTagsDataInput!
  create: UserCreateWithoutTagsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  friends_every: FriendWhereInput
  friends_some: FriendWhereInput
  friends_none: FriendWhereInput
  followers_every: UserWhereInput
  followers_some: UserWhereInput
  followers_none: UserWhereInput
  following_every: UserWhereInput
  following_some: UserWhereInput
  following_none: UserWhereInput
}

input UserWhereUniqueInput {
  id: ID
  username: String
  email: String
}

enum VisibilityFilter {
  Public
  Acquaintences
  Friends
  Family
  Custom
  Private
}
